% !TEX encoding = UTF-8 Unicode
% ---------------------------------------
% Reference Parameters
% Author: T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein
% Title: Introduction to Algorithms
% Publisher: The MIT Press
% Date: 2009

% ---------------------------------------
% TODO
%
%
%
%
%
%
%
%
%
%
%
%

% ---------------------------------------
% Computational Complexity Notations
\subsection{
نمادگزاری زمان اجرای الگوریتم
\cite{clrs2009}
}
برای تحلیل و بررسی رفتار تابع‌ها و الگوریتم‌های مختلف از
\textit{
نمادگذاری مجانبی
}\LTRfootnote{
Asymptotic Notation
}
استفاده می‌کنیم. تحلیل‌های
\textit{
غیر مجانبی
}\LTRfootnote{
Non-Asymptotic
}
نیز برای تحلیل الگوریتم‌ها و تحلیل رفتار تابع‌ها وجود دارد که در این پایان‌نامه بررسی نمی‌شود.

% ---------------------------------------

توجه کنید که در این بخش تنها به تعریف نمادگذاری و تحلیل رفتار مجانبی تابع پرداخته می‌شود. در رابطه با اینکه هر الگوریتم چگونه باید تحلیل شود، پس از ارائه‌ی بحث می‌شود. به عنوان مثال این موضوع که رفتار یک الگوریتم باید در قالب تعداد
\textit{
عملیات‌های ممیزشناور
}\LTRfootnote{
Floating Point Operations (FLOPs)
}
بیان شود و یا بر اساس تعداد
\textit{
گام‌ها
}\LTRfootnote{
Iterations
}
و یا ،در برخی موارد، بر حسب تعداد
\textit{
جستارها به یک اوراکل
}\LTRfootnote{
Queries to Oracle
}.
در ادبیات رایج است که در رابطه با تعداد گام‌ها صحبت شود و رفتار مجانبی بر حسب این عدد تحلیل شود. هرچند در کاربردها، باید دقت شود که کدام‌یک از تحلیل‌ها مرتبط خواهد بود زیرا عملکرد کلی الگوریتم به صورت مجموعه‌ای از تحلیل‌ها توصیف می‌شود. به عنوان نمونه اگر بتوان هزینه (زمان) هر جستار به یک اوراکل را ارزان (کم) کرد، می‌توان از روش‌هایی استفاده کرد که از نظر تعداد جستارها به یک اوراکل رفتار بدتری دارند و ممکن است عملکرد زمانی بهتری دریافت کرد.

% ---------------------------------------

به عنوان کلام آخر در این موضوع، توجه داشته باشید که عملکرد زمانی نیازمند تحلیل جداگانه‌ای است با توجه به زیرساخت‌هایی است که الگوریتم‌ها بر آن اجرا می‌شوند. این موضوع می‌تواند باعث شود که به‌روزترین روش‌ها که از یک منظر رفتار مجانبی بسیار شگفت‌انگیزی دارند در مسئله‌ی عملی شما کارا نباشند.


\subsubsection{
نمادگذاری مجانبی
}
نمادگذاری استفاده شده برای توصیف رفتار مجانبی الگوریتم‌ها، به شکل تابع‌هایی با دامنه و برد در اعداد طبیعی است. این نوع نمادگذاری‌ها برای بررسی
\textit{
بدترین حالت
}\LTRfootnote{
Worst-case
}
زمان اجرای یک تابع
$\mthfnc{T}(n)$
مناسب است. گاهی مناسب است که از نمادگذاری سوءاستفاده کنیم. به طور مثال، ممکن است دامنه‌ی تابع را اعداد حقیقی و یا زیرمجموعه‌ای از اعداد صحیح بگیریم. اما همواره باید مطمئن شد که منظور دقیق از نمادگذاری چیست که اگر از نمادگذاری سوءاستفاده شد، به استفاده‌ی اشتباه منجر نشود.

% ---------------------------------------

\textbf{
نمادگذاری
$\Theta$
}\\
برای تابع داده‌ی شده‌ی
$\mthfnc{g}: \hollow{N} \rightarrow \hollow{N}$،
مجموعه‌ی
$\Theta( \mthfnc{g} )$
را به شکل زیر تعریف می‌کنیم:
\[
\Theta( \mthfnc{g} ) = \left\lbrace \mthfnc{f}: \hollow{N} \rightarrow \hollow{N} \;\vert\; \exists c_l,c_u \geq 0, \; \exists n_0 \in \hollow{N} \; : \; \forall n \geq n_0 0 \leq c_l \mthfnc{g}(n) \leq \mthfnc{f}(n) \leq c_u \mthfnc{g}(n) \right\rbrace
\]
به صورت کلامی، تابع
$\mthfnc{f}$
به
$\Theta( \mthfnc{g} )$
تعلق دارد اگر بتواند در مقدارهای بسیار بزرگ، تابع
$\mthfnc{g}$
را با دو تابع
$c_l \mthfnc{g}$
و
$c_u \mthfnc{g}$
از پایین و بالا کراندار کرد. در این صورت می‌نویسیم
$\mthfnc{f} \in \Theta( \mthfnc{g} )$
و یا با سوءاستفاده از نمادگذاری می‌نویسیم
$\mthfnc{f} = \Theta( \mthfnc{g} )$.
و این رابطه را می‌خوانیم:
\textit{
$\mthfnc{g}$
یک کران مجانبا تنگ
\LTRfootnote{
Asymptotically Tight Bound
}
 برای
$\mthfnc{f}$
}
است. توجه کنید که تمامی اعضای مجموعه‌ی
$\Theta( \mthfnc{g} )$
باید
\textit{
مجانبا نامنفی
}\LTRfootnote{
Asymptotically Non-negative
}
باشند. از این به بعد در این قسمت فرض می‌کنیم که تمامی توابع مجانبا نامنفی هستند (که در تحلیل پیچیدگی محاسباتی
\LTRfootnote{
Computational Complexity
}
و زمان اجرا، فرض محدود کننده‌ای نیست).

% ---------------------------------------

\subsubsection{
نمادگذاری
$O$
}
نمادگذاری
$\Theta$
یک تابع را مجانبا از بالا و پایین کران‌دار می‌کرد. زمانی که تنها یک کران مجانبی از بالا داشته باشیم، از نمادگذاری
$O$
استفاده می‌کنیم.
\[
O( \mthfnc{g} ) = \left\lbrace \mthfnc{f}: \hollow{N} \rightarrow \hollow{N} \;\vert\; \exists c_u \geq 0, \; \exists n_0 \in \hollow{N} \; : \; \forall n \geq n_0 \; 0 \leq \mthfnc{f}(n) \leq c_u \mthfnc{g}(n) \right\rbrace
\]
از نمادگذاری
$O$
برای معرفی کران‌بالا برای یک تابع استفاده می‌شود، با دقت یک ضریب ثابت. به این معنی که در مقدارهای بزرگ‌تر از
$n_0$،
مقدار تابع
$\mthfnc{f}$
توسط ضریبی مثبت از تابع
$\mthfnc{g}$
از بالا کراندار می‌شود.

% ---------------------------------------

توجه کنید که با توجه به تعریف داریم
$\Theta( \mthfnc{g} ) \subseteq O( \mthfnc{g} )$
است زیرا که نمادگذاری
$\Theta$
کران‌دار کردن مجانبی از بالا و پایین را نتیجه می‌دهد.

% ---------------------------------------

دقت کنید که در بعضی متون در ادبیات بررسی پیچیدگی تابع‌ها، از نماد
$O$
به عنوان یک کران بالای مجانبا تنگ استفاده می‌شود در حالی که نماد انتخاب شده در این پایان‌نامه برای نمایش کران‌های مجانبا تنگ
$\Theta$
است. پس هرگاه از نماد
$O$
استفاده می‌شود، کران بالای مجانبی منظور است و در مورد تنگ بودن این کران فرضی وجود ندارد. این تمایز میان کران بالای مجانبی و کران بالای مجنابی تنگ در ادبیات پیچیدگی محاسبات کاری استاندارد است.

% ---------------------------------------

با استفاده از نمادگذاری
$O$
معمولا می‌توان زمان اجرای الگوریتم‌ها را با نگاه به ساختار کلّی آن توصیف کرد. به طور مثال:
\begin{algorithm}[H]
\caption*{
حلقه‌ی ساده
}
\begin{algorithmic}[1]
\REQUIRE
مسئله با بعد
$n$
  \FOR{ $i = 1$
  تا
  $N$ }
  \FOR{ $j = 1$
  تا
  $M$ }
  \STATE
  انجام یک سری عملیات
  \ENDFOR
  \ENDFOR
\end{algorithmic}
\end{algorithm}
فرض اینکه
\textit{
انجام یک سری عملیات
}
به طوری مجانبی از بالا توسط
$O( n )$
کراندار می‌شود، یک کران مجانبی بالا برای تعداد عملیات‌های این الگوریتم
$O( N  M n )$
خواهد بود. توجه کنید که این کران تنها به تحلیل یک گام در حلقه بستگی دارد و اگر به طور مثال کران بهتری برای بدنه‌ی حلقه بتوان یافت آنگاه کران کلّی بهتری می‌توان ارائه کرد و این ناشی از این است که نمادگذاری
$O$
تنها یک کران بالا را نشان می‌دهد که لزوما تنگ نیست.

% ---------------------------------------

خوب است باز اشاره کنیم که تحلیل الگوریتم‌ها معمولا بر اساس بدترین حالت و یا متوسط زمان اجرا
\LTRfootnote{
Expected running-time
}
است. در صورتی که به بیان بدترین حالت پیچیدگی الگوریتم تحلیل شود، می‌توان انتظار داشت که اجراهایی با زمان کمتر نیز وجود داشته باشند (در برخی مسئله‌های عملی، رخ دادن بدترین حالت کاملا نادر و در برخی کاملا رایج است). در صورتی که تحلیل بر اساس متوسط زمان اجرا باشد، اجراهایی با زمان کم‌تر و بیش‌تر را می‌توان انتظار داشت که فرکانس رخ‌دادن آن‌ها بستگی به توزیع ورودی مسئله دارد.

% ---------------------------------------

\subsubsection{
نمادگذاری
$\Omega$
}
همانگونه که نمادگذاری
$O$
در رابطه با کران مجانبی بالا صحبت می‌کرد، نمادگذاری
$\Omega$
در رابطه با یک کران مجانبی پایین صحبت می‌کند.

\[
\Omega( \mthfnc{g} ) = \left\lbrace \mthfnc{f}: \hollow{N} \rightarrow \hollow{N} \;\vert\; \exists c_l \geq 0, \; \exists n_0 \in \hollow{N} \; : \; \forall n \geq n_0 \; 0 \leq c_u \mthfnc{g}(n) \leq \mthfnc{f}(n) \right\rbrace
\]

طبق قضیه‌ی ۳.۱
\cite{clrs2009}
به ازای هر تابع
$f$
داریم
\[
\Theta( \mthfnc{f} ) = O( \mthfnc{f} ) \cap \Omega( \mthfnc{f} )
\]

% ---------------------------------------

زمانی که می‌گوییم
\begin{quote}
زمان اجرای الگوریتم
$\Omega( \mthfnc{g}(n) )$
است، منظور این است که به طور مجانبی، در سریع‌ترین حالت نیز به اندازه‌ی ضریبی ثابت از
$\mthfnc{g}(n)$
محاسبه نیاز است. یا به طور معادل یک ضریب ثابتی از
$\mthfnc{g}(n)$
کران مجانبی پایین برای سریع‌ترین اجرای مسئله است.
\end{quote}

% ---------------------------------------

حال به جمع‌بندی و بیانی دیگر از رفتار تابع‌ها می‌پردازیم. تابع‌های
$\mthfnc{f} : \hollow{N} \rightarrow \hollow{N}$
و
$\mthfnc{g} : \hollow{N} \rightarrow \hollow{N}$
را در نظر بگیرید. حالت‌های زیر رابطه‌ی مختلف میان رفتار آن‌ها را نشان می‌دهد:
\begin{itemize}
\item $\lim_{n\rightarrow \infty} \frac{ \mthfnc{f}(n) }{ \mthfnc{g}(n) } = \infty$\\
آنگاه رشد مجانبی
$\mthfnc{f}$
بیشتر از
$\mthfnc{g}$
است و داریم:
$\mthfnc{f} \in O( \mthfnc{g} )$
و
$\mthfnc{g} \in \Omega ( \mthfnc{f} ) $

\item $\lim_{n\rightarrow \infty} \frac{ \mthfnc{f}(n) }{ \mthfnc{g}(n) } = C > 0$\\
آنگاه رشد مجانبی
$\mthfnc{f}$
و
$\mthfnc{g}$
از یک مرتبه است و داریم:
$\mthfnc{f} \in \Theta( \mthfnc{g} )$
و
$\mthfnc{g} \in \Theta( \mthfnc{f} )$


\end{itemize}